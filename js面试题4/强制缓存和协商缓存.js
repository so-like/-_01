// 1强制缓存
// 服务器在返回的请求头中添加expires属性，该属性是一个时间值，每次客户端发送请求先和本地的缓存比较
// 看这个时间有没有过期 如果这个时间小于expires就说明本地缓存是有效果的 强制缓存生效 如果这个时间大雨了expires
// 则代表本地缓存失效客户端向服务器端重新请求

// 因为expires是一个绝对时间，它与客户端的网络状态等一些因素有关所以效率不是很高所以就引入了cache-control来判断
// 本地缓存是否过期，而且他的时间是相对的它有一个max-age用来表示最大存活时间而当expires和cache-control都存在时
// cache-control的优先级要高与expires


// 2.协商缓存
// 服务器在响应头中设置一个last-mindfined的属性用来表示这个资源最后一次修改的时间，当浏览器下一次发送请求时，
// 如果请求时间大于这个last-mindefined 则缓存失效，说明资源有改动 name就请求新的资源，如果没有改动就用本地缓存资源
// 这也有一个弊端就是last-mindefined是以秒为单位 所以当一个资源在一秒内不断更新就会导致他判断为不更新 所以推出了eatg
// 它就相当于一个哈希数 每一次修改都有唯一对应的值。所以它更加精确 而当两个同时存在时就会etag优先级更高
// 因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，
// 最好不要设置 Etag 属性。
